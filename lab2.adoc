== Типы данных, преобразования и указатели
Типы данных
Примитивные: int, float, double, char, bool и др.
Составные: массивы, структуры, классы.
Размер типа вычисляется через sizeof(type).

*Неявное преобразование:*
Автоматическое приведение типов компилятором:
int a = 5;
double b = a; // int → double

*Явное преобразование:*
static_cast: для безопасных преобразований 
double x = static_cast<double>(10) / 3;

reinterpret_cast: для низкоуровневых преобразований 
int* ptr = reinterpret_cast<int*>

*Почему преобразования плохи:*
Потеря точности (double → int)
Неопределённое поведение(если типы несовместимы)

*Указатель* — переменная, хранящая адрес памяти
Операции:
int* ptr = &x; 
*ptr = 10;     
ptr++;         

*Почему нельзя вычитать указатели на разные объекты:*
Результат не имеет смысла

Битовая арифметика
Установка бита:
x |= (1 << n); 

Сброс бита:
x &= ~(1 << n); 

Переключение бита:
x ^= (1 << n); 



== Унарные + и -
+x: Нет эффекта для чисел, но может вызвать преобразование типа
short s = 5;
int i = +s; 
-x: Смена знака числа 



== Проблема с float и 17 000 000
Число 17 000 000 в float (32 бита) хранится так:
Мантисса: 23 бита (~7 десятичных цифр точности)

При +1: Разница меньше единицы младшего разряда → округление до исходного значения

Пример:
float f = 17'000'000;
cout << (f == f + 1); // true!




== Почему 7 != 7

Типы разные:
int a = 7;
double b = 7.0000000000001;
cout << (a == b); // false
Битовое представление:7 как int и float имеют разную кодировку