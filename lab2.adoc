== Отчет по теме: "Типы данных, указатели и битовые операции"
:author: Нигматзянов К.М.
:group: ЕТ-211
== Титульный лист

[.title]

                                      
                                       
  Выполнил: Нигматзянов К.М.           
  Группа: ЕТ-211                       
                                       
                                       
                                       




== 1. Основные понятия

=== Типы данных и их размер
* **Примитивные типы**: `int`, `float`, `double`, `char`, `bool` и др.
* **Размер типа**: вычисляется оператором `sizeof()`. Зависит от архитектуры (например, `int` обычно 4 байта).
* **Неявное преобразование**: автоматическое приведение типов (например, `int + float -> float`).
* **Явное преобразование**: принудительное приведение через `static_cast`, `reinterpret_cast` и др.

=== Преобразование типов
* `static_cast`: для безопасных преобразований (например, `float` в `int`).
* `reinterpret_cast`: для низкоуровневых преобразований (например, указатель в `int`).
* **Почему плохо**: может привести к потере данных или UB.

=== Указатели
* **Указатель** — переменная, хранящая адрес памяти.
* **Операции**: разыменование (`*p`), арифметика (`p++`, `p - q`), сравнение.
* **Вычитание разных указателей**: UB, так как они могут быть из разных массивов/объектов.

=== Битовая манипуляция
* Установка бита: `x |= (1 << n)`
* Сброс бита: `x &= ~(1 << n)`
* Переключение бита: `x ^= (1 << n)`

== 2. Унарные операторы `+` и `-`
* `+x`: возвращает значение `x` (для симметрии с `-`)
* `-x`: возвращает отрицательное значение `x`

== 3. Проблема с `float + 1`
* **Причина**: ограниченная точность `float` (23 бита мантиссы). При больших числах (17e6) единица теряется из-за округления.

== 4. Подробный разбор: почему `7 != 7`?

=== Исходный код
[source,cpp]
----
#include <iostream>

int main() {
    int i = 7;
    i = i++ + ++i;
    std::cout << (i != 7) << std::endl; // Выводит 1 (true)
}
----

=== Причины неочевидного поведения
1. **Нарушение sequence points**:
   - Выражение `i++ + ++i` содержит две модификации `i` без точки следования между ними.
   - Стандарт C++ объявляет это *неопределённым поведением (UB)*.

2. **Как компилятор может это обработать**:
   - Вариант 1: Сначала выполнить `i++` (возврат 7, затем `i=8`), потом `++i` (`i=9`, возврат 9). Итог: `7 + 9 = 16`.
   - Вариант 2: Вычислить `++i` (i=8), потом `i++` (возврат 8, i=9). Итог: `8 + 8 = 16`.
   - Вариант 3: Другая логика — результат непредсказуем.

3. **Почему сравнивается с 7**:
   - Даже если кажется, что `i` должно быть 7, из-за UB компилятор может оптимизировать код неочевидным образом.
   - В данном случае `i` после вычислений не равно 7 (например, 16), поэтому `(i != 7)` даёт `true`.


== Общий вывод: При написании кода на C++ необходимо учитывать множество нюансов, связанных с типами данных, указателями, битовыми операциями и особенностями операторов. Особое внимание следует уделять избежанию неопределённого поведения, которое может привести к непредсказуемым результатам. Соблюдение лучших практик и использование современных инструментов анализа кода помогут создавать более надёжные и предсказуемые программы.